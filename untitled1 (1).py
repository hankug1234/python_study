# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LX_LdskeMR5eHBzNpAt98k6pp6A-ppLn
"""

def clone(gems_dict):
    new_gems_dict = {}
    keys = list(gems_dict.keys())
    for gem in keys:
        new_gems_dict[gem] = gems_dict[gem]
    return new_gems_dict    
    
def solution(gems):
    max_index = len(gems)-1
    gems_dict = {}
    for gem in gems:
        if gem in list(gems_dict.keys()):
            gems_dict[gem] +=1
        else:
            gems_dict[gem] = 1
    
    if len(gems_dict) == 1:
        return [1,1]

    left_gems_dict = clone(gems_dict)
    left_gems_dict[gems[max_index]] -=1
    
    right_gems_dict = clone(gems_dict)
    right_gems_dict[gems[0]] -=1        
            
    queue = [(left_gems_dict,[0,max_index-1],0),(right_gems_dict,[1,max_index],1)]
    answer = []

    while(len(queue) != 0):
        data = queue.pop(0)
        values = list(data[0].values())
        if 0 in values:
            if (data[1][0]-1 >=0) and (data[0][gems[data[1][0]-1]] == 0):
                answer.append([data[1][0]-1,data[1][1]])
            else:
                answer.append([data[1][0],data[1][1]+1]) 
            continue
        
        left_gems_dict = clone(data[0])
        left_gems_dict[gems[data[1][1]]] -=1
        queue.append((left_gems_dict,[data[1][0],data[1][1]-1],0))

        if data[2]== 1:
          right_gems_dict = clone(data[0])
          right_gems_dict[gems[data[1][0]]] -=1
          queue.append((right_gems_dict,[data[1][0]+1,data[1][1]],1))    
    index_end = len(answer)-1
    if answer[index_end][0] <= answer[index_end-1][0]:
        answer = answer[index_end]
    else:
        answer = answer[index_end-1]
    answer[0]+=1
    answer[1]+=1
    return answer


    
gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]
gems2 = ["ZZZ", "YYY", "NNNN", "YYY", "BBB"]
gems3 = ["XYZ", "XYZ", "XYZ"]
gems4 = ["AA", "AB", "AC", "AA", "AC"]
print(solution(gems))
print(solution(gems2))
print(solution(gems3))
print(solution(gems4))

a = [1,2,3,4]
print(a.pop(0))
print(a)

import numpy as np
def solution(gems):
    max_index = len(gems)-1
    gems_dict = {}
    for gem in gems:
        if gem in list(gems_dict.keys()):
            gems_dict[gem] +=1
        else:
            gems_dict[gem] = 1
    if len(gems_dict) == 1:
        return [1,1]
        
    queue = [(gems_dict,[0,max_index],1)]
    answer = [1,max_index+1]
    mean_len = 1000000
    
    while(len(queue) != 0):
        data = queue.pop(0)
        values = list(data[0].values())
        if 0 in values:
            if mean_len > (data[1][1]-data[1][0]+2):
                mean_len = (data[1][1]-data[1][0]+2)
                if (data[2] ==1):
                    answer = [data[1][0],data[1][1]+1]
                else:
                    answer = [data[1][0]+1,data[1][1]+2]
            continue
        
        left_gems_dict = data[0].copy()
        left_gems_dict[gems[data[1][1]]] -=1
        queue.append((left_gems_dict,[data[1][0],data[1][1]-1],0))

        if data[2]== 1:
            right_gems_dict = data[0].copy()
            right_gems_dict[gems[data[1][0]]] -=1
            queue.append((right_gems_dict,[data[1][0]+1,data[1][1]],1))   
    return answer        

gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]
gems2 = ["ZZZ", "YYY", "NNNN", "YYY", "BBB"]
gems3 = ["XYZ", "XYZ", "XYZ"]
gems4 = ["AA", "AB", "AC", "AA", "AC"]
print(solution(gems))
print(solution(gems2))
print(solution(gems3))
print(solution(gems4))

"""#include <string>
#include <vector>
#include <list>
#include <map>
#include <iostream>
using namespace std;

class Data{
    private:
        map<string,int>m; 
        vector<int>v;
        int s;
    public:
        Data(map<string,int>& m,vector<int> v,int s);
        map<string,int> getm();
        vector<int> getv();
        int gets();
};
Data::Data(map<string,int>& im,vector<int> iv,int is){m=im; v=iv;s=is;};
map<string,int> Data::getm(){return m;};
vector<int> Data::getv(){return v;};
int Data::gets(){return s;};

vector<int> solution(vector<string> gems) {
    vector<int> answer;
    int max_index = gems.size()-1;
    map<string,int> gems_dict;
    int i = 0;
    for(i=0;i<=max_index;i++){
        if(gems_dict.find(gems[i]) != gems_dict.end())
            gems_dict[gems[i]] +=1;
        else
            gems_dict[gems[i]] = 1;
    }
    
    if(gems_dict.size() == 1)
        return {1,1};
    
    Data pd(gems_dict,{0,max_index},1);
    list<Data> queue;
    queue.push_back(pd);
    answer = {1,max_index+1};
    int mean_len = 1000000;
    int state = 0;
    while(queue.size() != 0){
        auto iter = queue.begin();
        Data d = *iter;
        map<string,int> m = d.getm();
        queue.pop_front();
        for(auto miter = m.begin();miter!=m.end();miter++){
            if(miter->second == 0){
                state = 1;
                break;
            }
        }
        if(state ==1){
            state = 0;
            if(mean_len >(d.getv()[1]-d.getv()[0]+2)){
                mean_len = (d.getv()[1]-d.getv()[0]+2);
                if(d.gets() == 1)
                    answer = {d.getv()[0],d.getv()[1]+1};
                else
                    answer = {d.getv()[0]+1,d.getv()[1]+2};  
            }      
         continue;   
        }
        map<string,int> left_gems_dict = d.getm();
        left_gems_dict[gems[d.getv()[1]]] -=1;
        Data ld(left_gems_dict,{d.getv()[0],d.getv()[1]-1},0);
        queue.push_back(ld);
        
        if(d.gets() == 1){
        map<string,int> right_gems_dict = d.getm();
        right_gems_dict[gems[d.getv()[0]]] -=1; 
        Data rd(right_gems_dict,{d.getv()[0]+1,d.getv()[1]},1);
        queue.push_back(rd);
        }
       
    }
    return answer;
}
"""

def solution(gems):
  max = len(gems)
  total_count = len(set(gems))
  answer = [0,max-1]
  mean_len = max
  start = 0
  end = max
  for n in range(start,end):
    s = set()
    for i in range(n,end):
      s.add(gems[i])
      if len(s) == total_count:
        l = i - n+1
        if mean_len > l:
          mean_len = l
          answer[0] = n
          answer[1] = i
        break

  return[answer[0]+1, answer[1]+1]        

gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]
gems2 = ["ZZZ", "YYY", "NNNN", "YYY", "BBB"]
gems3 = ["XYZ", "XYZ", "XYZ"]
gems4 = ["AA", "AB", "AC", "AA", "AC"]
print(solution(gems))
print(solution(gems2))
print(solution(gems3))
print(solution(gems4))

def solution(gems):
    max = len(gems)
    total_count = len(set(gems))
    answer = [0,max-1]
    mean_len = max
    if total_count == 1:
        return [1,1]
    
    for n in range(max):
        if (n!=(max-1)) and (gems[n] == gems[n+1]):
          continue
        s = set()
        for i in range(n,max):
            s.add(gems[i])
            if (n-i+1) >= mean_len:
                break
            if len(s) == total_count:
                l = i - n+1
                if mean_len > l:
                    mean_len = l
                    answer[0] = n
                    answer[1] = i
                break
    return[answer[0]+1, answer[1]+1]

import collections

def solution2(gems):
    num = len(set(gems))
    ret = []

    left = 0
    counter = collections.Counter()
    for right in range(len(gems)):
        counter[gems[right]] += 1
        right += 1
        print(len(counter))
        while len(counter) == num:
            counter[gems[left]] -= 1
            if counter[gems[left]] == 0:
                del counter[gems[left]]
            left += 1
            ret.append([left, right])      

    return sorted(ret, key = lambda x: (x[1]-x[0], x[0]))[0]
gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]
solution2(gems)

